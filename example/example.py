import flimsy
import six
#################
# Test Cases
#################

# Create a parameterizable test definition
class Test(flimsy.TestCase):
    # Instead of users needing to explicitly call super().__init__, init is passed the same arguments as __init__.
    # If name is passed as a keyword argument to __init__, it will be used as the name of the test. 
    # If not, init must set the name attribute.
    def init(self, value):
        self.value = value
        if not hasattr(self, 'name'):
            self.name =  'TestPass' if value else 'TestFail'

    def test(self, test_parameters):
        assert self.value

# Create a parameterized version of the test
false_test = Test(False)
# Create another parameterized version, but supply a name rather than the parameterize's version.
true_test = Test(True, name='TestPassCustom')


# Create tests from a function, name of the function is automatically used as test name.
@flimsy.testfunction
def test_function(test_parameters):
    pass

# Create tests using non-python related applications and checking return value.
flimsy.test_application('Script Test', 'test.sh')


#################
# Test Suites
#################

# At the most basic level, a TestSuite is just a linear collection of tests.
# Tests contained in the default TestSuite will run in the given order.
tests = [false_test, true_test]
flimsy.TestSuite(tests, name='Truth Tests')

# Tests not explicity placed into a TestSuite will automatically be grouped into a test suite autogenerated for the module.
# The type of this default test suite can be changed for the current module.
class CustomSuite(flimsy.TestSuite):
    pass
flimsy.config.defaultsuite = CustomSuite


# TestSuites provide an iterator interface for test runners.
# It's possible to modify the order of tests by overriding the __iter__ method::
class ReverseSuite(flimsy.TestSuite):
    def __iter__(self):
        return reversed(self.tests)

############
# Fixtures
############

# Like many test frameworks Flimsy supports the concept of fixtures.
# Fixtures are a way to perform setup and cleanup of requirements for test execution.

# Unlike some test frameworks, fixtures are enumerated and initialized in two steps.
# After all tests files have been enumerated and all tests have been parameterized, fixtures for each test scheduled to run will be parameterized by calling init().
# Then the test execution phase begins. 
# Before each test item is executed the associated fixture will be setup(), and after the test, teardown() will be called.
# This two phase approach is particularly useful for interacting with build systems or any time a fixture needs to know of all other fixtures or scheduled tests.
class BuildSystemFixture(flimsy.Fixture):
    targets = []
    def setup(self, testsuites):
        if not subprocess.call('make ' + ''.join(targets)):
            testsuites.skip()

flimsy.globalfixture(BuildSystemFixture(name='Make Build System'))
class BuildTargetFixture(flimsy.Fixture):
    def init(self, target):
        BuildSystemFixture.targets.append(target)
        self.target = target
# In the above we create a BuildTargetFixture and a global BuildSystemTarget.
# When each BuildTargetFixture is initialized before tests begin, they add themselves to this list.
# Then, just before the first test suite begins running, the setup method of the BuildSystemFixture is executed, and all the targets are supplied to make.


# Fixtures can also skip test items if they are unable to perform the necessary initialization.
class SkipFixture(flimsy.Fixture):
    def setup(self, testitem):
        testitem.skip()

    def teardown(self, testitem):
        pass

class SkippedTest(flimsy.TestCase):
    fixtures = [SkipFixture()]
    def test(self):
        assert False

##############
# Runners
##############

# To allow modification of test running logic, TestCases and TestSuites contain a runner class attribute which defines the Runner subclass to use.
# This allows modification of test running logic.
# For example, you might wish that the test suite would fail all additional tests after a single test has failed.
# To modify the default running behavior, overrride the run method.
class IterativeRunner(flimsy.SuiteRunner):
    def run(self):
        self.presuite()
        test_iter = iter(self.suite)
        for test in test_iter:
            result = test.run()
            if result = flimsy.Failed:
                break
        for test in test_iter:
            test.result = flimsy.Failed
        self.postsuite()
class FailFastSuite(flimsy.TestSuite):
    runner = IterativeRunner


#################
# Logging
#################

# Flimsy uses a single common log to offer a single point of contact for gathering test status, output, and debug messages.
# This log is thread safe and allows for multiple consumers of information.

# As a convenience, the test_parameters object contains a log accessor to log messages at a given level and automatically attach the test scope.
# To write a debug message to the log during a test::
@flimsy.testfunction
def debug_message_test(test_parameters):
    test_parameters.log.debug('This is a debug message')
    test_parameters.log.warn('This is a warning message')

# The log will also automatically capture print statements, so we could just have easily used the print function.
# However, print statements are considered Stdout rather than a LogMessage type.
# This distiction makes more sense once we introduce the verbosity and stream flags.
# To increase log message output verbosity supply the '-v' flag.
# Each additional flag will increase the verbosity level to a cap.
# Increasing the verbosity level however will not cause test stdout or stderr output to display.
# To enable output of test stdout and stderr, supply the '-s' flag.
# Now all terminal output will be directed to their respective streams as tests are executed.


#################
# Configuration
#################
flimsy.config.defaultsuite
flimsy.config.defaultsuiterunner
flimsy.config.defaulttestrunner

flimsy.config.defaultpathfilter

# In order to collect tests items, flimsy executes the python files containing tests.
# To prevent accidental running of unrelated scripts, by default flimsy will first check files for a top level import statement from flimsy.
flimsy.config.checkforimport

###############
# Other
###############

# Perform special logic if this module is not being collected by whimsy.
# NOTE: Only tests which are instantiated in the collecting module will be collected on this pass.
if not flimsy.collecting == __name__:
    six.print_('This module is not currently being collected, but it was imported.')



# Test Phases:
# * Test Collection
# * Test Parameterization
# * Fixture Parameterization
# * Global Fixture Setup
# * Iteratevely run suites:
#    * Suite Fixture Setup
#    * Iteratively run tests:
#       * Test Fixture Setup
#       * Run Test
#       * Test Fixture Teardown
#    * Suite Fixture Teardown
# * Global Fixture Teardown