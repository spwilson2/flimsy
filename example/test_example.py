import flimsy
import six
#################
# Test Cases
#################

# Create a parameterizable test definition
class Test(flimsy.TestCase):
    # Instead of users needing to explicitly call super().__init__, init is passed the same arguments as __init__.
    # If name is passed as a keyword argument to __init__, it will be used as the name of the test. 
    # If not, init must set the name attribute.
    def init(self, value):
        self.value = value
        if not hasattr(self, 'name'):
            self.name =  'TestPass' if value else 'TestFail'

    def test(self, test_parameters):
        assert self.value

# Create a parameterized version of the test
false_test = Test(False)
# Create another parameterized version, but supply a name rather than the parameterize's version.
true_test = Test(True, name='TestPassCustom')


# Create tests from a function, name of the function is automatically used as test name.
@flimsy.testfunction
def test_function(test_parameters):
    pass

# Create tests using non-python related applications and checking return value.
flimsy.test_application('Script Test', 'test.sh')

#################
# Test Suites
#################

# At the most basic level, a TestSuite is just a linear collection of tests.
# Tests contained in the default TestSuite will run in the given order.
tests = [false_test, true_test]
flimsy.TestSuite(tests, name='Truth Tests')

# Tests not explicity placed into a TestSuite will automatically be grouped into a test suite autogenerated for the module.
# The type of this default test suite can be changed for the current module.
class CustomSuite(flimsy.TestSuite):
    pass
flimsy.config.defaultsuite = CustomSuite


# TestSuites provide an iterator interface for test runners.
# It's possible to modify the order of tests by overriding the __iter__ method::
class ReverseSuite(flimsy.TestSuite):
    def __iter__(self):
        return reversed(self.tests)
ReverseSuite(tests, name='Reversed Truth Tests')

############
# Fixtures
############

# Like many test frameworks Flimsy supports the concept of fixtures.
# Fixtures are a way to perform setup and cleanup of requirements for test execution.

# Unlike some test frameworks, fixtures are enumerated and initialized in two steps.
# After all tests files have been enumerated and all tests have been parameterized, fixtures for each test scheduled to run will be parameterized by calling init().
# Then the test execution phase begins. 
# Before each test item is executed the associated fixture will be setup(), and after the test, teardown() will be called.
# This two phase approach is particularly useful for interacting with build systems or any time a fixture needs to know of all other fixtures or scheduled tests.
class BuildSystemFixture(flimsy.Fixture):
    targets = []
    def setup(self, testitem):
        import subprocess
        if subprocess.call('make ' + ''.join(self.targets), shell='/bin/bash'):
            self.skip(testitem)

#flimsy.globalfixture(BuildSystemFixture(name='Make Build System'))
class BuildTargetFixture(flimsy.Fixture):
    def init(self, target):
        BuildSystemFixture.targets.append(target)
        self.target = target
# In the above we create a BuildTargetFixture and a global BuildSystemTarget.
# When each BuildTargetFixture is initialized before tests begin, they add themselves to this list.
# Then, just before the first test suite begins running, the setup method of the BuildSystemFixture is executed, and all the targets are supplied to make.


# Fixtures can also skip tests if they are unable to perform the necessary initialization.
class SkipFixture(flimsy.Fixture):
    name = 'Test Skipper'
    def setup(self, testitem):
        testitem.skip()

    def teardown(self, testitem):
        pass

class SkippedTest(flimsy.TestCase):
    fixtures = [SkipFixture()]
    def test(self):
        assert False

##############
# Runners
##############

# For more advanced test writers flimsy enables modification of test running logic.
# TestCases and TestSuites contain a runner class attribute which defines the Runner subclass to use.
# As an example, you might wish that the test suite would fail all additional tests after a single test has failed.
# To modify the default running behavior, overrride the run method.
class IterativeRunner(flimsy.SuiteRunner):
    def run(self):
        self.presuite()
        test_iter = iter(self.suite)
        for test in test_iter:
            result = test.runner(test).run()
            if result == flimsy.Failed:
                print 'Test "%s" failed, skipping remaining tests in suite' % test.name
                # TODO Define logging interface to report this.
                break
        for test in test_iter:
            test.result = flimsy.Failed
        self.postsuite()

class FailFastSuite(flimsy.TestSuite):
    runner = IterativeRunner

FailFastSuite(tests, name='Fail Fast Test Suite')